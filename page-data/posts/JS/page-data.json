{
    "componentChunkName": "component---src-templates-category-template-js",
    "path": "/posts/JS",
    "result": {"pageContext":{"currentCategory":"JS","categories":["All","JS","WEB","CSS","TOOL","BLOG"],"edges":[{"node":{"id":"e7d917e4-a79a-5a9d-ab44-8e48f17fa0a6","excerpt":"💙 문자 (String) 1. String String 은 전역 객체이며 문자열의 생성자이다.  하지만 리터럴 방식으로 문자열을 만드는 것이 훨씬 간단하기 때문에 보통은 리터럴 방식을 사용한다. 2. String.prototype.indexOf() 호출한 String 객체에서 주어진 값과 알치히는 첫 번째 인덱스를 반환한다.\n일치하는 값이 없으면 -1 을 반환한다. 3. String.length 문자열의 길이를 반환한다. 4. String.prototype.slice() 문자열의 일부를 추출하면서 새로운 문자열을 반환한다.\n첫 번째 인수로는 0부터 시작하는 인덱스를, 두 번째 인수로는 종료할 인덱스를 전달한다. 중요한 점은 종료할 인덱스의 이전까지 반환된다는 것이다.\n종료할 인덱스를 생략하면 문자열의 마지막까지 반환된다. 5. String.prototype.replace() 문자 또는 문자열을 교체하여 반환한다. 6. String.prototype.match() 특정한 정규표현식과…","fields":{"slug":"/javascript/string/"},"frontmatter":{"categories":"JS","title":"[JS] 문자 (String)","date":"2022.04.10"}},"next":{"fields":{"slug":"/javascript/extends/"}},"previous":null},{"node":{"id":"9e2d17f7-3684-514c-adfb-47b644609e1f","excerpt":"💙 상속 (확장) 자바스크립트의 클래스 부분에서 extends 키워드를 통해\n특정한 클래스를 가지고 와서 확장(상속) 할 수 있고\n확장된 클래스는 super 라는 함수를 통해서 내부의 원하는 위치에서 실행할 수 있다. 💙 상속 (확장)","fields":{"slug":"/javascript/extends/"},"frontmatter":{"categories":"JS","title":"[JS] 상속 (확장)","date":"2022.04.10"}},"next":{"fields":{"slug":"/javascript/es6-classes/"}},"previous":{"fields":{"slug":"/javascript/string/"}}},{"node":{"id":"80a8f43a-c8da-5c4a-badc-54f455e72493","excerpt":"💙 ES6 Classes 일반함수 작성 시 콜론과 function 키워드를 생략하여 사용이 가능하다. 자바스크립트는 프로토타입 기반의 프로그래밍 언어이지만,\n조금 더 안정적이고 신뢰도가 높은 다른 객체지향 프로그래밍 언어들의 영향을 받아서\n클래스라는 개념을 흉내낸 새로운 문법을 ES6 에서 제공하기 시작했다.  키워드를 사용하여 클래스를 명시하고,\n 키워드를 사용하여 생성자 함수를 만들 수 있다. 별도로 prototype 속성을 사용하지 않아도\n바로 prototype 으로 만들어지는 메소드가 정의된다. 💙 ES6 Classes","fields":{"slug":"/javascript/es6-classes/"},"frontmatter":{"categories":"JS","title":"[JS] ES6 Classes","date":"2022.04.07"}},"next":{"fields":{"slug":"/javascript/this/"}},"previous":{"fields":{"slug":"/javascript/extends/"}}},{"node":{"id":"b8289597-7f7e-5061-96e2-8deba68e9468","excerpt":"💙 this 일반 (Normal) 함수는 호출 위치에 따라 this 가 정의된다.\n화살표 (Arrow) 함수는 자신이 선언된 함수 범위에서 this 가 정의된다. setTimeout, setInterval 함수의 콜백함수로는 화살표함수를 사용하는 것이 활용도가 높다.\n특정한 범위에서 this 를 가르킬 수 있기 때문이다. 💙 this","fields":{"slug":"/javascript/this/"},"frontmatter":{"categories":"JS","title":"[JS] this","date":"2022.04.06"}},"next":{"fields":{"slug":"/javascript/class/"}},"previous":{"fields":{"slug":"/javascript/es6-classes/"}}},{"node":{"id":"0304a00f-b23f-5c69-a8ce-f1e8fa1f11fc","excerpt":"💙 클래스 (Class) 객체 데이터를 일일이 하나씩 만드는 것은\n간단한 애플리케이션이라면 상관이 없지만, 더욱 로직이 복잡해지고 큰 규모의 서비스를 만든다고 가정하면\n이러한 로직들은 효율이 많이 떨어지게 된다. 여기서 효율이란 일종의 메모리를 관리하는 효율을 이야기한다.\n로직이 똑같은데도 불구하고 만들어내는 객체 데이터의 개수만큼\n데이터와 함수가 각각 메모리에 할당되기 때문이다. 이러한 경우 자바스크립트의 를 사용할 수 있다. 중괄호라는 특정한 기호를 통해서 객체 데이터를 한번에 만들어낼 수 있다.\n이렇게 특정한 기호만 가지고 데이터를 만들어내는 것을 이라고 한다. 대표적으로 따옴표 기호를 사용해 문자 데이터를 만들어내는 것, (“A” => 문자 데이터)\n대괄호 기호를 사용해 배열 데이터를 만들어내는 것이 있다. ([] => 배열 데이터) new 라는 키워드를 통해서 생성자 함수로 실행한 결과를 반환해서 할당된 변수를 라고 한다.\n또한 클래스의 이름은 파스칼 케이스로 작성해야 한…","fields":{"slug":"/javascript/class/"},"frontmatter":{"categories":"JS","title":"[JS] 클래스 (Class)","date":"2022.04.05"}},"next":{"fields":{"slug":"/javascript/callback/"}},"previous":{"fields":{"slug":"/javascript/this/"}}},{"node":{"id":"2b4ac3a6-c6ce-56da-908f-d5d372cc1d3b","excerpt":"💙 콜백 (Callback) 콜백이란 함수의 인수로 사용되는 함수를 말한다.\n특정한 실행 위치를 보장하는 용도로 많이 활용된다. Dog 이 먼저 출력되고 나서 3초 후에 Cat 이 출력된다. 3초 후에 Cat 이 먼저 출력되고 바로 Dog 이 출력된다. setTimeout 뿐만아니라,\n로직이 복잡해서 처리하는 데 시간이 많이 걸리는 경우에 콜백 함수를 이용하면\n모든 처리가 완료된 후에 원하는 내용을 실행할 수 있다. 💙 콜백 (Callback)","fields":{"slug":"/javascript/callback/"},"frontmatter":{"categories":"JS","title":"[JS] 콜백 (Callback)","date":"2022.04.05"}},"next":{"fields":{"slug":"/javascript/timer-function/"}},"previous":{"fields":{"slug":"/javascript/class/"}}},{"node":{"id":"7c781e14-99a7-55e3-9e29-cb01387edf2d","excerpt":"💙 타이머 함수 1. setTimeout 일정 시간 후 함수를 실행한다. 2. setInterval 시간 간격마다 함수를 실행한다. 3. clearTimeout 설정된 Timeout 함수를 종료한다. 4. clearInterval 설정된 Interval 함수를 종료한다. 💙 타이머 함수 1. setTimeout 2. setInterval 3. clearTimeout 4. clearInterval","fields":{"slug":"/javascript/timer-function/"},"frontmatter":{"categories":"JS","title":"[JS] 타이머 함수","date":"2022.04.05"}},"next":{"fields":{"slug":"/javascript/hoisting/"}},"previous":{"fields":{"slug":"/javascript/callback/"}}},{"node":{"id":"aeaeb999-e12a-553d-9df7-68cc226ac24f","excerpt":"💙 호이스팅 (Hoisting) 가 유효범위 최상단으로 끌어올려지는 현상을 의미한다. 1. 함수 표현 double 함수가 실행될 때에는\n해당 함수가 아직 만들어지지 않기 때문에 에러가 발생한다.\nUncaught TypeError: double is not a function … 을 사용하는 경우에는 함수가 만들어지기 전에 함수를 호출하는 것이 불가능하다. 2. 함수 선언 을 사용하는 경우에는, \n함수 선언부가 유효범위 최상단으로 끌어올려지는 현상인 \n호이스팅이 발생하기 때문에 에러가 발생하지 않는다. 함수 호출 시 사용하는 이름을 보고\n대략적으로 함수의 내용을 유추할 수 있기 때문에 함수를 코드 중간중간에 작성하는 것 보다는,\n함수가 직접적으로 만들어지는 부분은 코드의 최하단 부분에 작성하고\n호출을 위에서 아래 방향으로 하는 것이 전체적인 코드의 흐름을 파악하는 데 효율적일 수 있다. 💙 호이스팅 (Hoisting) 1. 함수 표현 2. 함수 선언","fields":{"slug":"/javascript/hoisting/"},"frontmatter":{"categories":"JS","title":"[JS] 호이스팅 (Hoisting)","date":"2022.04.03"}},"next":{"fields":{"slug":"/javascript/iife/"}},"previous":{"fields":{"slug":"/javascript/timer-function/"}}},{"node":{"id":"5eb9d224-a16d-5c93-8172-508ce9b43936","excerpt":"💙 IIFE (Immediately- Invoked Function Expession, 즉시 실행 함수) 함수를 만들자마자 한 번만 실행하고 이후에 사용할 일이 없을 경우 사용한다. 익명 함수를 소괄호로 묶어준 후,\n소괄호가 끝나는 부분에 또 다른 소괄호를 붙여준다. 익명 함수를 소괄호로 묶어준 후,\n중괄호가 끝나는 부분에 소괄호를 붙여준다. 두번 째 방법이 더욱 권장되는 방법이다. 💙 IIFE (Immediately- Invoked Function Expession, 즉시 실행 함수)","fields":{"slug":"/javascript/iife/"},"frontmatter":{"categories":"JS","title":"[JS] IIFE (즉시 실행 함수)","date":"2022.04.03"}},"next":{"fields":{"slug":"/javascript/arrow-function/"}},"previous":{"fields":{"slug":"/javascript/hoisting/"}}},{"node":{"id":"f10234ca-7052-5f11-b261-4eae30767cd7","excerpt":"💙 화살표 함수 (Arrow Function) 1. function () {} function 키워드를 사용함 익명함수, 함수 표현이다. 2. () => {} function 키워드 대신 화살표를 사용하는 함수 표현이다. function 키워드 함수와 화살표 함수의 가장 큰 차이점은\n함수 내부의 코드가 한 줄인 경우 축약이 가능하다는 것이다.(중괄호, return 키워드)\n또한 매개변수가 하나인 경우 소괄호 생략이 가능하다. 축약형으로 객체 데이터를 반환하는 경우에는 \n중괄호가 사용되기 때문에, 함수의 블록과 혼동될 수 있다.\n이러한 경우 중괄호를 소괄호로 한 번 묶어주면 된다. 💙 화살표 함수 (Arrow Function) 1. function () {} 2. () => {}","fields":{"slug":"/javascript/arrow-function/"},"frontmatter":{"categories":"JS","title":"[JS] 화살표 함수","date":"2022.04.03"}},"next":{"fields":{"slug":"/javascript/arguments/"}},"previous":{"fields":{"slug":"/javascript/iife/"}}},{"node":{"id":"96bc6f00-f482-5b65-9a6a-05c77b83cf2d","excerpt":"💙 Arguments 함수 내부에서는 따로 매개변수를 지정하지 않아도\narguments 라는 특정한 객체를 사용할 수 있다. 함수를 실행할 때 사용하는 인수가 너무 많아서\n매개변수를 일일이 지정하기 어려울 경우 arguments 객체를 활용할 수 있다.\n하지만 되도록 매개변수 이름을 명시하는 것이 좋다. 💙 Arguments","fields":{"slug":"/javascript/arguments/"},"frontmatter":{"categories":"JS","title":"[JS] Arguments","date":"2022.04.03"}},"next":{"fields":{"slug":"/javascript/type-conversion/"}},"previous":{"fields":{"slug":"/javascript/arrow-function/"}}},{"node":{"id":"28790533-41f4-5991-9f9e-101cfe00695e","excerpt":"💙 형변환 (Type Conversion) 1. Truthy (참 같은 값) 2. Falsy (거짓 같은 값) 이러한 Truthy, Falsy 값들은 각각 true, false 로 이 발생하여 해석된다.\nTruthy 는 너무 많기 때문에 Falsy 를 잘 기억해 두면 된다. 💙 형변환 (Type Conversion) 1. Truthy (참 같은 값) 2. Falsy (거짓 같은 값)","fields":{"slug":"/javascript/type-conversion/"},"frontmatter":{"categories":"JS","title":"[JS] Truthy, Falsy","date":"2022.04.03"}},"next":{"fields":{"slug":"/javascript/identity-equality-operator/"}},"previous":{"fields":{"slug":"/javascript/arguments/"}}},{"node":{"id":"d900c62e-6c44-5b46-b298-964cb215c1cc","excerpt":"💙 일치연산자와 동등연산자 1. 일치연산자 (Identity Operator) 두 데이터의 데이터타입, 값이 일치하는지 비교한다. 1. 동등연산자 (Equality Operator) 두 데이터의 값만 일치하는지 비교한다.\n동등연산자를 사용하면 형변환이 일어나면서 두 데이터를 비교하기 때문에\n의도하지 않게 다른 값이 같다는 결과가 나오기 때문에 사용이 권장되지 않는다. 💙 일치연산자와 동등연산자 1. 일치연산자 (Identity Operator) 1. 동등연산자 (Equality Operator)","fields":{"slug":"/javascript/identity-equality-operator/"},"frontmatter":{"categories":"JS","title":"[JS] 일치연산자와 동등연산자","date":"2022.04.03"}},"next":{"fields":{"slug":"/javascript/scope/"}},"previous":{"fields":{"slug":"/javascript/type-conversion/"}}},{"node":{"id":"2334b576-3baf-5204-934e-4da1e2104030","excerpt":"💙 변수의 유효범위 (Variable Scope) 1. 블록 레벨 유효범위 (Block Level Scope) 블록 레벨 유효범위를 가지는 변수 키워드에는 ,  가 있다. const 변수가 선언된 해당 블록 안에 있기 때문에 동작이 가능하다. const 변수가 선언된 해당 블록을 벗어나기 때문에 동작이 불가능하다.\nUncaught ReferenceError: a is not defined at scope 에러가 발생한다. const 변수가 선언된 해당 블록 안에 있기는 하지만,\n변수에 값이 할당된 코드보다 먼저 출력되기 때문에 undefined 출력된다.  변수가 선언된 해당 블록을 벗어나기 때문에 동작이 불가능하다.\nUncaught ReferenceError: a is not defined at scope 에러가 발생한다. 위 코드의 const 키워드를  으로 바꾸어도 결과는 같다. let, const 키워드를 사용하는 변수는 블록 레벨의 유효 범위를 가진다.\n변수가 선언되어져 …","fields":{"slug":"/javascript/scope/"},"frontmatter":{"categories":"JS","title":"[JS] 변수의 유효범위","date":"2022.04.03"}},"next":{"fields":{"slug":"/javascript/typeof/"}},"previous":{"fields":{"slug":"/javascript/identity-equality-operator/"}}},{"node":{"id":"7422f945-d7b5-5d28-96a5-28713bda56f1","excerpt":"💙 데이터 타입 확인 1. typeof() typeof(데이터)를 통해 데이터의 타입을 확인할 수 있다. 하지만 null, 객체, 배열은 object 로만 확인이 가능하다.\nobject 의 type 까지 확인하기 위해서는 아래의 메소드를 호출하면 된다. 2. Object.prototype.toString.call() 💙 데이터 타입 확인 1. typeof() 2. Object.prototype.toString.call()","fields":{"slug":"/javascript/typeof/"},"frontmatter":{"categories":"JS","title":"[JS] 데이터 타입 확인","date":"2022.04.03"}},"next":{"fields":{"slug":"/javascript/ecma-script/"}},"previous":{"fields":{"slug":"/javascript/scope/"}}},{"node":{"id":"3a2271f2-b236-5b48-b689-f73ecb1a17fb","excerpt":"💙 ECMA Script ECMA Script (ES) 란,\nEcma International (자바스크립트 국제 표준화 기구) 이 정의한 \n표준화된 스크립트 프로그래밍 언어를 말한다. 자바스크립트를 표준화하기 위해서 만들어졌으며\nJavaScript 라고 부르는 프로그래밍 언어의 표준화된 명칭이 바로 ECMA Script 이다. 2015년 6월에 ECMA Script 2015 (ES6) 가 출판되어 크게 변화되었으며,\n이후에는 1년에 한 번씩 버전이 업데이트 되면서 기능들이 추가되고 있다. 대부분 IE 는 ES5 버전 이하만 지원하며, 비교적 신형 브라우저들은 ES6 버전 이상도 지원하고 있다. 이러한 문제는 ES6 이상의 문법들을 작성한 후에 Babel 을 통해 \n구형 브라우저에서도 동작할 수 있는 ES5 버전 문법으로 변환하여 해결이 가능하다. 💙 ECMA Script","fields":{"slug":"/javascript/ecma-script/"},"frontmatter":{"categories":"JS","title":"[JS] ECMA Script","date":"2022.04.03"}},"next":{"fields":{"slug":"/web/gitignore/"}},"previous":{"fields":{"slug":"/javascript/typeof/"}}},{"node":{"id":"5e5ff5c8-653d-59e2-bacb-523a6a3a9d8d","excerpt":"💙 유의적 버전 (Semantic Versioning, SemVer) 여기서 버전의 숫자들은 각각 아래의 의미를 나타낸다.  ..\nMajor.Minor.Patch 1. Major 기존 버전과 호환되지 않는  \n(예: Windows OS) 2. Minor 기존 버전과 호환되는 새로운  3. Patch 기존 버전과 호환되는  4. ^Major.Minor.Patch Major 버전 안에서 가장 최신 버전으로 업데이트 가능\npackage.json 파일에서 업데이트 하려는 모듈의 버전 앞에 ^(캐롯) 기호가 명시되어 있어야 한다.\n이 기호는 npm update 를 통해 최신 버전으로 업데이트 할 수 있다는 것을 의미한다. 참고: https://semver.org/lang/ko/ 💙 유의적 버전 (Semantic Versioning, SemVer) 1. Major 2. Minor 3. Patch 4. ^Major.Minor.Patch","fields":{"slug":"/javascript/semantic-versioning/"},"frontmatter":{"categories":"JS","title":"[JS] 유의적 버전","date":"2022.04.02"}},"next":{"fields":{"slug":"/javascript/node-js/"}},"previous":{"fields":{"slug":"/web/gitignore/"}}},{"node":{"id":"2da5c6dc-4451-5db0-9cea-f929b2d0425d","excerpt":"💙 Node.js 1. Node.js Node.js는 Chrome V8 JavaScript 엔진으로 빌드된 JavaScript 런타임이다.\n런타임이란 프로그래밍 언어가 동작하는 환경을 말한다. 브라우저를 제어하기 위해 JavsScript 언어를 사용하는 것 처럼,\n컴퓨터 제어하기 위해, 웹 페이지 개발에 도움을 받기 위해 Node.js 를 사용한다. 웹 페이지를 더욱 효율적으로 만들기 위한 sass, less, babel 과 같은 모듈들은\n브라우저에서 직접적으로 동작할 수 없기 때문애\n일단 Node.js 환경에서 모듈을 이용해 개발하고,\n그 후에 브라우저에서 동작될 수 있도록\nNode.js 가 html, css, js 로 소스코드를 변환해준다. [Node.js 설치]\nhttps://nodejs.org/ko/ 위 사이트에 접속하여 LTS 버전을 설치한다. LTS (Long Term Supported) 는 장기적으로 안정되고 신뢰도가 높은 지원이 보장되는 버전으로,\n유지/보수와 보안(…","fields":{"slug":"/javascript/node-js/"},"frontmatter":{"categories":"JS","title":"[JS] Node.js","date":"2022.03.29"}},"next":{"fields":{"slug":"/web/html-entities/"}},"previous":{"fields":{"slug":"/javascript/semantic-versioning/"}}},{"node":{"id":"31ddae32-18d1-5ac0-88a0-34bd1d0dc882","excerpt":"💙 메소드 체이닝 (Method Chaning) 메소드를 마치 체인처럼 연결해서 사용하는 것을 의미한다. 💙 메소드 체이닝 (Method Chaning)","fields":{"slug":"/javascript/method-chainning/"},"frontmatter":{"categories":"JS","title":"[JavaScript] 메소드 체이닝","date":"2022.03.20"}},"next":{"fields":{"slug":"/javascript/dom-api/"}},"previous":{"fields":{"slug":"/web/favicon/"}}},{"node":{"id":"2fc011fc-fc34-519e-b44c-8c54ccd0fe74","excerpt":"💙 DOM API 1. DOM API Document Object Model, Application Programming Interface defer: 페이지가 모두 로드된 후에 해당 외부 스크립트가 실행됨을 명시함 2. querySelector & addEventListener 3. classList (add, remove) 4. querySelectorAll & forEach 5. textContent 💙 DOM API 1. DOM API 2. querySelector & addEventListener 3. classList (add, remove) 4. querySelectorAll & forEach 5. textContent","fields":{"slug":"/javascript/dom-api/"},"frontmatter":{"categories":"JS","title":"[JavaScript] DOM API","date":"2022.03.20"}},"next":{"fields":{"slug":"/javascript/object/"}},"previous":{"fields":{"slug":"/javascript/method-chainning/"}}},{"node":{"id":"0c0abb7f-fed3-5a72-b9ec-8f5888127667","excerpt":"💙 객체와 메소드 객체 안에 있는 속성에 함수를 할당한 것은\n속성이 아니라 메소드라고 한다. 💙 객체와 메소드","fields":{"slug":"/javascript/object/"},"frontmatter":{"categories":"JS","title":"[JavaScript] 객체 & 메소드","date":"2022.03.19"}},"next":{"fields":{"slug":"/javascript/function/"}},"previous":{"fields":{"slug":"/javascript/dom-api/"}}},{"node":{"id":"e4dead3f-7718-5882-8af6-62b91e401da1","excerpt":"💙 함수의 선언과 함수의 표현 1. 기명 함수 (이름이 있는 함수) function 키워드를 사용하고,\n이름을 직접적으로 명시하는 것을 함수의 선언이라고 한다. 2. 익명 함수 (이름이 없는 함수) 이름의 명시 없이,\n변수에 할당하여 사용하는 것은 함수의 표현이라고 한다. 💙 함수의 선언과 함수의 표현 1. 기명 함수 (이름이 있는 함수) 2. 익명 함수 (이름이 없는 함수)","fields":{"slug":"/javascript/function/"},"frontmatter":{"categories":"JS","title":"[JavaScript] 함수 선언 & 함수 표현","date":"2022.03.19"}},"next":{"fields":{"slug":"/javascript/parameter/"}},"previous":{"fields":{"slug":"/javascript/object/"}}},{"node":{"id":"a3e9ee8e-60fd-5af4-a1f1-290ab8c4dbd8","excerpt":"💙 매개변수와 인수 1. 매개변수 (Parameters) 함수 안에서 사용하는 데이터를 받아주는 매개체가 되는 변수\n함수 안에서만 사용이 가능 2. 인수 (Arguments) 함수의 매개변수가 받아 줄 특정한 데이터 💙 매개변수와 인수 1. 매개변수 (Parameters) 2. 인수 (Arguments)","fields":{"slug":"/javascript/parameter/"},"frontmatter":{"categories":"JS","title":"[JavaScript] 매개변수 & 인수","date":"2022.03.19"}},"next":{"fields":{"slug":"/javascript/null/"}},"previous":{"fields":{"slug":"/javascript/function/"}}},{"node":{"id":"d58edc14-e973-57a8-8309-51430aabbdb7","excerpt":"💙 null 과 undefined 1.null 어떤 값이 의도적으로 비어있음을 의미한다. 2. undefined 값이 할당되지 않은 상태를 나타낸다. [ null 체크 ]\n체크대상 === null 보다는, 체크대상 == null 로 하는 것이 좋다.\n 는  이기 때문에\n체크대상 == null 로 체크하면 null 과 undefined 를 모두 체크할 수 있기 때문이다. 0 == null == undefined == ‘’ == false 💙 null 과 undefined 1.null 2. undefined","fields":{"slug":"/javascript/null/"},"frontmatter":{"categories":"JS","title":"[JavaScript] Null & Undefined","date":"2022.03.19"}},"next":{"fields":{"slug":"/javascript/variable/"}},"previous":{"fields":{"slug":"/javascript/parameter/"}}},{"node":{"id":"40b003a4-60c7-558e-a64a-211793705fc3","excerpt":"💙 변수와 예약어 1. 변수 (Variable) 데이터를 지정하고 참조(사용)하는 데이터의 이름 var: 사용하지 않는 것이 권장됨 (호이스팅 문제) let: 재할당 가능 const: 재할당 불가능 2. 예약어 (Reserved Word) 특별한 의미를 가지고 있어, 변수나 함수 이름 등으로 사용할 수 없는 단어 if, else, false, true, while, this, break … 💙 변수와 예약어 1. 변수 (Variable) 2. 예약어 (Reserved Word)","fields":{"slug":"/javascript/variable/"},"frontmatter":{"categories":"JS","title":"[JavaScript] 변수 & 예약어","date":"2022.03.19"}},"next":{"fields":{"slug":"/web/notation/"}},"previous":{"fields":{"slug":"/javascript/null/"}}}]}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}